# 💡 생성자 함수에 의한 객체 셍성

### ✔ Object 생성자 함수
- `new` 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다
- 빈 객체를 생성한 이후 프로퍼티 또는 메서드를 추가하여 객체를 완성할 수 있다
- **하지만** 리터럴로 생성하는 것이 더 간편하기 때문에 유용하게 사용하지는 않는다
```
// 빈 객체의 생성
const person = new Object();

// 프로퍼티 추가
person.name = 'Lee';
person.sayHello = function () {
  console.log('Hi! My name is ' + this.name);
};

console.log(person); // {name: "Lee", sayHello: f}
person.sayHello(); // Hi! My name is Lee
```

### ✔ 생성자 함수

#### 1. 객체 리터럴에 의한 객체 생성 방식의 문제점
- 객체 리터럴에 의한 생성 방식은 직관적이고 간편하다
- **하지만** 리터럴에 의한 생성 방식은 단 하나의 객체만 생성한다

#### 2. 생성자 함수에 의한 객체 생성 방식의 장점
- 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러개를 간편하게 생성할 수 있다

#### 3. 생성자 함수의 인스턴스 생성 과정
1. 인스턴스 생성과 this 바인딩
  - 암묵적으로 빈 객체가 생성된다
  - 이 빈 객체가 생성자 함수가 생성한 인스턴스이다
2. 인스턴스 초기화
  - 생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다
  ```
  function Circle(radius) {
    // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다

    // 2. this에 바인딩되어 있는 인스턴스를 초기화한다
    this.radius = radius;
    this.getDiameter = function () {
      return 2 + this.radius;
    };
  }
  ```
3. 인스턴스 반환
  - 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩한 this가 암묵적으로 변환된다

#### 4. 내부 메서드 [[Call]] & [[Construct]]
- 함수는 객체이므로 일반 객체와 동일하게 동작할 수 있다
- 다만 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다
- 함수가 일반 함수로서 호출되면 함수 객체의 내부 메서도 Call이 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메서드 Construct가 호출된다

#### 5. constructor와 non-constructor의 구분
- constructor : 함수 선언문, 함수 표현식, 클래스
- non-constructor : 메서드, 화살표 함수

#### 6. new 연산자
- 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다
- new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다
- **즉, 함수 객체의 내부 메서드 Call이 호출되는 것이 아니라 Construct가 호출된다**