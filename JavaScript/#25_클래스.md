# 💡 클래스

### ✔ 클래스는 프로토타입의 문법적 설탕인가?
- 클래스를 프로토타입 기반 객체 생성 패턴의 단순한 문법적 설탕이라고 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 좀 더 합당하다
---

### 클래스 정의
- 클래스는 `class` 키워드를 사용하여 정의한다
```
const Person = class {};  // 익명 클래스 표현식
const Person = class MyClass{}; // 가명 클래스 표현식
```
- 클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수 있는 일급 객체라는 것을 의미하고, 다음과 같은 특징을 갖는다
  - 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다
  - 변수나 자료구조에 저장할 수 있다
  - 함수의 매개변수에게 전달할 수 있다
  - 함수의 반환값으로 사용할 수 있다
---

### 클래스 호이스팅
- 클래스는 함수로 평가된다
- 클래스 선언문은 마치 호이스팅이 발생하지 않는 것처럼 보이나 그렇지 않다
```
const Person = '';

{
  // 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.
  console.log(Person); 
  // ReferenceError: Cannot access 'Person' before initialization
  
  // 클래스 선언문
  class Person {};
}
```
---

### 인스턴스 생성
- 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다
```
class Person {}

// 인스턴스 생성
const me = new Person();
console.log(me); // Person {}

class Person {}

// 클래스를 new 연산자 없이 호출하면 타입 에러가 발생한다
const me = Person();
// TypeError: Class constructor Foo cannot be invoked without 'new'
```

### 메서드
- 클래스 몸체에는 0개 이상의 메서드만 선언할 수 있다
- 클래스 몸체에서 정의할 수 있는 메서드는 constructor(생성자), 프로토타입 메서드, 정적 메서드의 세 가지가 있다

#### 1. constructor
- `constructor`는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드이며, 이름을 변경할 수 없다
```
class Person {
  // 생성자
  constructor(name) {
    // 인스턴스 생성 및 초기화
    this.name = name;
  }
}
```
- 클래스는 평가되어 함수 객체가 된다
- 모든 함수 객체가 가지고 있는 `prototype` 프로퍼티가 가리키는 프로토타입 객체의 `constructor` 프로퍼티는 클래스 자신을 가리키고 있다<br>
- 클래스가 생성한 인스턴스의 내부를 들여다보면 수퍼 클래스의 `constructor` 내부에서 `this`에 추가한 프로퍼티가 인스턴스의 프로퍼티로 추가된 것을 확인할 수 있다
- 즉, `constructor` 내부의 `this`는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다<br>
- 그런데 클래스가 평가되어 생성된 함수 객체나 인스턴스 어디에도 `constructor` 메서드를 확인할 수 없다
- 이는 `constructor`가 단순한 메서드가 아니라는 것을 의마한다
- `constructor`는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체코드의 일부가 된다
- 즉, 클래스 정의가 평가되면 `constructor`의 기술된 동작을 하는 함수 객체가 된다
  - `constructor`는 클래스 내에 최대 한 개만 존재할 수 있다.
  - `constructor`는 생략할 수 있다. 생략하면 빈 `constructor`가 암묵적으로 정의된다.
  - 인스턴스를 초기화하려면 `constructor`를 생략해서는 안된다.
  - `constructor`는 별도의 반환문을 갖지 않아야 한다. 암묵적으로 `this`, 즉 인스턴스를 반환하기 때문이다.